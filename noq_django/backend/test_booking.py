from django.test import TestCase
from django.core.exceptions import ValidationError

# Generated by CodiumAI
from backend.models import Booking
from datetime import datetime
from backend.models import Product
from backend.models import BookingStatus
from backend.models import Available
from datetime import timedelta
from backend.models import Region, Client, User, Host, State


class test_Booking(TestCase):

    def setUp(self):

        region = Region(name="City")
        region.save()

        Host.objects.create(name="Host", city="City", region=region),

        user = User()
        user.save()

        male_client = Client.objects.create(
            first_name="John",
            last_name="Doe",
            gender="M",
            street="123 Main St",
            postcode="12345",
            city="New York",
            country="USA",
            phone="123-456-7890",
            email="john.doe@example.com",
            unokod="ABC123",
            day_of_birth=datetime.now().date(),
            personnr_lastnr="1234",
            region=Region.objects.get(name="City"),
            requirements=None,
            last_edit=datetime.now().date(),
            user=user,
        )

        female_client = Client.objects.create(
            first_name="Mary",
            last_name="Doe",
            gender="K",
            street="123 Main St",
            postcode="12345",
            city="New York",
            country="USA",
            phone="123-456-7890",
            email="john.doe@example.com",
            unokod="ABC123",
            day_of_birth=datetime.now().date(),
            personnr_lastnr="1234",
            region=Region.objects.get(name="City"),
            requirements=None,
            last_edit=datetime.now().date(),
            user=user,
        )

        # Create a woman-only product
        product = Product.objects.create(
            name="Product",
            description="Description",
            total_places=10,
            host=Host.objects.get(city="City"),
            type="woman-only",
            requirements=None,
        )

        # Create product with 1 total places
        product_one_place = Product.objects.create(
            name="Product",
            description="Description",
            total_places=1,
            host=Host.objects.get(city="City"),
            type="room",
            requirements=None,
        )

        status = BookingStatus.objects.bulk_create([
            BookingStatus(id=State.PENDING, description="pending"),
            BookingStatus(id=State.DECLINED, description="declined"),
            BookingStatus(id=State.ACCEPTED, description="accepted"),
            BookingStatus(id=State.CHECKED_IN, description="checked_in"),
            BookingStatus(id=State.IN_QUEUE, description="in_queue"),
            BookingStatus(id=State.RESERVED, description="reserved"),
            BookingStatus(id=State.CONFIRMED, description="confirmed"),
        ])

    # Booking a product with valid data saves the booking and updates availability
    def test_booking_with_valid_data(self):

        # Initialize a Booking object
        booking = Booking()

        # Set the attributes of the Booking object
        booking.start_date = datetime.now() + timedelta(days=1)
        booking.product = Product.objects.first()
        booking.user = Client.objects.get(gender="K")
        booking.status = BookingStatus.objects.get(id=State.PENDING)

        # Save the Booking object
        booking.save()

        # Assert that the booking is saved
        assert Booking.objects.filter(id=booking.id).exists()

        # Assert that availability is updated
        availability = Available.objects.filter(
            product=booking.product, available_date=booking.start_date
        ).first()
        assert availability is not None
        assert availability.places_left == booking.product.total_places - 1

    # Booking a product with an invalid date raises ValidationError
    def test_booking_with_invalid_date(self):

        product = Product.objects.get(id=1)
        client = Client.objects.get(gender="K")
        status = BookingStatus.objects.first()

        # Initialize a Booking object
        booking = Booking()

        # Set the attributes of the Booking object with an invalid date
        booking.start_date = datetime.now() - timedelta(days=1)
        booking.product = product
        booking.user = client
        booking.status = status

        # Assert that a ValidationError is raised when trying to save the booking
        with self.assertRaises(ValidationError):
            booking.save()

    # Booking a product with a male user and woman-only type raises ValidationError
    def test_booking_with_male_user_and_woman_only_type_raises_validation_error(
        self,
    ):
        # Create a male user
        client = Client.objects.get(gender="M")

        # Create a woman-only product
        product = Product.objects.create(
            name="Product",
            description="Description",
            total_places=10,
            host=Host.objects.get(city="City"),
            type="woman-only",
            requirements=None,
        )

        # Try to book the product with the male user
        with self.assertRaises(ValidationError):
            Booking.objects.create(
                start_date=datetime.now().date(),
                product=product,
                user=client,
                status=BookingStatus.objects.create(description="pending"),
            )

    # Booking a product with the same user and date as the current booking does not raise ValidationError
    def test_booking_with_same_user_and_date(self):
        # Create two bookings with valid data
        booking = Booking()
        booking.start_date = datetime.now()
        booking.product = Product.objects.get(id=2)
        booking.user = Client.objects.get(gender="K")
        booking.status = BookingStatus.objects.get(id=State.PENDING)
        booking.save()

        # Try to create another booking with the same user and date
        duplicate_booking = Booking()
        duplicate_booking.start_date = booking.start_date
        duplicate_booking.product = booking.product
        duplicate_booking.user = Client.objects.get(gender="K")
        duplicate_booking.status = booking.status

        # Assert that a ValidationError is raised
        with self.assertRaises(ValidationError):
            duplicate_booking.save()

        # Assert that the original booking still exists
        assert Booking.objects.filter(id=booking.id).exists()

        # Assert that availability is not updated
        availability = Available.objects.filter(
            product=booking.product, available_date=booking.start_date
        ).first()
        assert availability is not None
        assert availability.places_left == booking.product.total_places - 1

    # Accepting a booking when out of places should raise error
    def test_booking_out_of_places(self):
        # Create two bookings with valid data, first one is accepted,
        # second is not accepted as there is no places left
        booking = Booking()
        booking.start_date = datetime.now()
        booking.product = Product.objects.get(total_places=1)
        booking.user = Client.objects.get(id=1)
        booking.status = BookingStatus.objects.get(id=State.PENDING)
        booking.save()
        availability = Available.objects.filter(
            product=booking.product, available_date=booking.start_date
        ).first()
        assert availability is not None
        self.assertEqual(availability.places_left, 0)

        booking_2 = Booking()
        booking_2.start_date = datetime.now()
        booking_2.product = Product.objects.get(total_places=1)
        booking_2.user = Client.objects.get(id=2)
        # It should not be possible to add second pending booking
        booking_2.status = BookingStatus.objects.get(id=State.PENDING)
        with self.assertRaises(ValidationError):
            booking_2.save()

        # Set second booking in queue, this should not change number of
        # available places
        booking_2.status = BookingStatus.objects.get(id=State.IN_QUEUE)
        booking_2.save()

        availability = Available.objects.filter(
            product=booking.product, available_date=booking.start_date
        ).first()
        assert availability is not None
        self.assertEqual(availability.places_left, 0)

        # Decline the first pending booking
        booking.status = BookingStatus.objects.get(id=State.DECLINED)
        booking.save()

        # After declining pending booking there should be available
        # places for booking
        availability = Available.objects.filter(
            product=booking.product, available_date=booking.start_date
        ).first()
        assert availability is not None
        self.assertEqual(availability.places_left, 1)

        booking_2.status = BookingStatus.objects.get(id=State.ACCEPTED)
        booking_2.save()
        # After booking is moved from queue to accepted there should
        # not be any places left for booking
        availability = Available.objects.filter(
            product=booking.product, available_date=booking.start_date
        ).first()
        assert availability is not None
        self.assertEqual(availability.places_left, 0)
